! This file forms part of the NETWORK_SYNTHESIS project
!
! Software to generate Spice sub-circuit models to reproduce
! impedance functions specified as either s-domain rational functions
! or pole-residue representations. 
!
! Copyright (C) 2018 University of Nottingham
!
! NETWORK_SYNTHESIS is free software: you can redistribute it and/or modify it under the 
! terms of the GNU General Public License as published by the Free Software 
! Foundation, either version 3 of the License, or (at your option) any later 
! version.
! 
! NETWORK_SYNTHESIS is distributed in the hope that it will be useful, but 
! WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
! for more details.
! 
! A copy of the GNU General Public License version 3 can be found in the 
! file COPYING.txt in the root or at <http://www.gnu.org/licenses/>.
! 
! NETWORK_SYNTHESIS uses the EISPACK library. EISPACK is subject to 
! the GNU Lesser General Public License. A copy of the GNU Lesser General Public 
! License version can be found in the file COPPYING.LESSER.txt 
! or at <http://www.gnu.org/licenses/>.
! 
! The University of Nottingham can be contacted at: ggiemr@nottingham.ac.uk
!
! Author C Smartt
!
  CALL get_command_argument(1 , argument1, argument1_length)

  if (argument1_length.NE.0) then
  
    filename =trim(argument1)
  
  else

    write(*,*)'Enter the name of the transfer function file (either in pole-zero format or rational function format)'

    read(*,'(A)')filename

  end if

  verbose=.FALSE.
  verbose=.TRUE.
  
  CALL get_command_argument(2 , argument2, argument2_length)

  if (argument2_length.NE.0) then
  
    if( (argument2(1:1).EQ.'v').OR.(argument2(1:1).EQ.'V') ) verbose=.TRUE.
  
  end if
    
! Read the transfer function coefficients from file

  open(unit=10,file=filename)
  
  read(10,'(A)')line
  if ( (line(1:1).EQ.'v').OR.(line(1:1).eq.'V') ) then
! We have to work with a pole-zero form as generated by the Vector fitting process

    read(10,*,ERR=9000)H_PR%order
    read(10,*,ERR=9000)H_PR%wnorm
    read(10,*,ERR=9000)H_PR%R
    read(10,*,ERR=9000)H_PR%L
    
    wnorm_save=H_PR%wnorm
    H_PR%wnorm=1d0                            ! work with the normalised filter
    
    read(10,*,ERR=9000)     ! comment line
    
    H_PR%n_complex_pole_pairs=0
    H_PR%n_complex_poles=0
    H_PR%n_real_poles=0
    
    ALLOCATE( H_PR%complex_pole(1:H_PR%order) )
    ALLOCATE( H_PR%poles(1:H_PR%order) )
    ALLOCATE( H_PR%residues(1:H_PR%order) )
    
    do i=1,H_PR%order
    
      read(10,*,ERR=9000)re_p,im_p,re_r,im_r
      
      H_PR%poles(i)=cmplx(re_p,im_p)
      H_PR%residues(i)=cmplx(re_r,im_r)
      
      if (im_p.NE.0d0) then
        H_PR%complex_pole=.TRUE.
        H_PR%n_complex_poles=H_PR%n_complex_poles+1
      else
        H_PR%complex_pole=.FALSE.
        H_PR%n_real_poles=H_PR%n_real_poles+1
      end if
    end do
    
    H_PR%n_complex_pole_pairs=H_PR%n_complex_poles/2
    
    H=Convert_filter_S_PR_to_S(H_PR)
    
! renormalise such that b%coeff(border)=1
    
    norm=H%a%coeff(0)
    if (norm.ne.0d0) then
      H%a%coeff(0:H%a%order)=H%a%coeff(0:H%a%order)/norm
      H%b%coeff(0:H%b%order)=H%b%coeff(0:H%b%order)/norm
    end if
    
    read(10,*,ERR=9000)   ! comment line
    read(10,*,ERR=9000)wmin,wmax,nw       ! Note that these are normalised frequencies
 
  else
  
! We have to work with a rational function form as generated by the GGI_TLM_filter_fit process


    read(10,*,ERR=9000)wmin,wmax           ! note these are frequencies and need to be normalised
    read(10,*,ERR=9000)                    ! comment line

    CALL read_Sfilter(H,10)
    wnorm_save=H%wnorm
    H%wnorm=1d0                            ! work with the normalised filter
    
! Apply normalisation to the frequency range
     wmin=wmin*2d0*pi/wnorm_save
     wmax=wmax*2d0*pi/wnorm_save
     nw=200               ! set a reasonable value here...

  end if ! filter type
  
  close(unit=10)
  
  write(*,*)' Transfer function '

  CALL write_Sfilter_local(H)
 
! Evaluate the transfer function and write to file
  write(*,*)''
  
! evaluate functions for checking and write to files
! i.e. the frequency response of the initial filter funtion
! and the frequency response of the continued fraction function

  open(unit=20,file='Rational_funtion.fout')

  wstep=(wmax-wmin)/(nw-1)
  
  do i=1,nw
  
    s=(0d0,1d0)*(wmin+wstep*(i-1))    ! normalised frequency
  
! evaluate the frequency response of the initial filter funtion
    
    num_fs=(0d0,0d0)
    
    sn=(1d0,0d0)    
    do loop=0,H%a%order
      num_fs=num_fs+H%a%coeff(loop)*sn
      sn=sn*s
    end do
    
    den_fs=(0d0,0d0)
    
    sn=(1d0,0d0)    
    do loop=0,H%b%order
      den_fs=den_fs+H%b%coeff(loop)*sn
      sn=sn*s
    end do
    
    H_rational=num_fs/den_fs
    
    write(20,8030)wnorm_save*(wmin+wstep*(i-1))/6.28318530718,real(H_rational),aimag(H_rational), &
                                                   abs(H_rational)
    
8030 format(4ES16.8)
  
  end do
  
  close(unit=20)
  
  CALL pole_zero_cancel(H)
 
!  H_PR=Convert_filter_S_to_S_PR(H)
!  if (verbose) CALL write_S_PR_filter(H_PR)
