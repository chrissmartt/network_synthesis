  CALL get_command_argument(1 , argument1, argument1_length)

  if (argument1_length.NE.0) then
  
    filename =trim(argument1)
  
  else

    write(*,*)'Enter the name of the rational function data file'

    read(*,'(A)')filename

  end if

  verbose=.FALSE.
  
  CALL get_command_argument(2 , argument2, argument2_length)

  if (argument2_length.NE.0) then
  
    if( (argument2(1:1).EQ.'v').OR.(argument2(1:1).EQ.'V') ) verbose=.TRUE.
  
  end if
    
! Read the transfer function coefficients from file

  open(unit=10,file=filename)
  
  read(10,'(A)')line
  if ( (line(1:1).EQ.'v').OR.(line(1:1).eq.'V') ) then
! We have to work with a pole-zero form as generated by the Vector fitting process

    read(10,*,ERR=9000)H_PR%order
    read(10,*,ERR=9000)H_PR%wnorm
    read(10,*,ERR=9000)H_PR%R
    read(10,*,ERR=9000)H_PR%L
    
    wnorm_save=H_PR%wnorm
    H_PR%wnorm=1d0                            ! work with the normalised filter
    
    read(10,*,ERR=9000)     ! comment line
    
    H_PR%n_complex_pole_pairs=0
    H_PR%n_complex_poles=0
    H_PR%n_real_poles=0
    
    ALLOCATE( H_PR%complex_pole(1:H_PR%order) )
    ALLOCATE( H_PR%poles(1:H_PR%order) )
    ALLOCATE( H_PR%residues(1:H_PR%order) )
    
    do i=1,H_PR%order
    
      read(10,*,ERR=9000)re_p,im_p,re_r,im_r
      
      H_PR%poles(i)=cmplx(re_p,im_p)
      H_PR%residues(i)=cmplx(re_r,im_r)
      
      if (im_p.NE.0d0) then
        H_PR%complex_pole=.TRUE.
        H_PR%n_complex_poles=H_PR%n_complex_poles+1
      else
        H_PR%complex_pole=.FALSE.
        H_PR%n_real_poles=H_PR%n_real_poles+1
      end if
    end do
    
    H_PR%n_complex_pole_pairs=H_PR%n_complex_poles/2
    
    H=Convert_filter_S_PR_to_S(H_PR)
    
! renormalise such that b%coeff(border)=1
    
    norm=H%a%coeff(0)
    if (norm.ne.0d0) then
      H%a%coeff(0:H%a%order)=H%a%coeff(0:H%a%order)/norm
      H%b%coeff(0:H%b%order)=H%b%coeff(0:H%b%order)/norm
    end if
    
    read(10,*,ERR=9000)   ! comment line
    read(10,*,ERR=9000)wmin,wmax,nw       ! Note that these are normalised frequencies
 
  else
  
! We have to work with a rational function form as generated by the GGI_TLM_filter_fit process
    read(line,*,ERR=9000)aorder
    read(10,*,ERR=9000)border
  
    H=allocate_Sfilter(aorder,border)
  
    read(10,*,ERR=9000)H%wnorm
    wnorm_save=H%wnorm
    H%wnorm=1d0                            ! work with the normalised filter
  
    read(10,*,ERR=9000)   ! comment line
  
    do i=0,aorder
      read(10,*,ERR=9000)H%a%coeff(i)
    end do
  
    read(10,*,ERR=9000)   ! comment line
  
    do i=0,border
      read(10,*,ERR=9000)H%b%coeff(i)
    end do
  
    read(10,*,ERR=9000)   ! comment line
    read(10,*,ERR=9000)wmin,wmax,nw       ! Note that these are normalised frequencies

  end if ! filter type
  
  close(unit=10)
  
  write(*,*)' Transfer function '

  CALL write_Sfilter_local(H)
 
! Evaluate the transfer function and write to file
  write(*,*)''
  
! evaluate functions for checking and write to files
! i.e. the frequency response of the initial filter funtion
! and the frequency response of the continued fraction function

  open(unit=20,file='Rational_funtion.fout')

  wstep=(wmax-wmin)/(nw-1)
  
  do i=1,nw
  
    s=(0d0,1d0)*(wmin+wstep*(i-1))    ! normalised frequency
  
! evaluate the frequency response of the initial filter funtion
    
    num_fs=(0d0,0d0)
    
    sn=(1d0,0d0)    
    do loop=0,H%a%order
      num_fs=num_fs+H%a%coeff(loop)*sn
      sn=sn*s
    end do
    
    den_fs=(0d0,0d0)
    
    sn=(1d0,0d0)    
    do loop=0,H%b%order
      den_fs=den_fs+H%b%coeff(loop)*sn
      sn=sn*s
    end do
    
    H_rational=num_fs/den_fs
    
    write(20,8030)wnorm_save*(wmin+wstep*(i-1))/6.28318530718,real(H_rational),aimag(H_rational), &
                                                   abs(H_rational)
    
8030 format(4ES16.8)
  
  end do
  
  close(unit=20)
  
  CALL pole_zero_cancel(H)
 
!  H_PR=Convert_filter_S_to_S_PR(H)
!  if (verbose) CALL write_S_PR_filter(H_PR)
